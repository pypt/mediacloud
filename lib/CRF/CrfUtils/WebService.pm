package CRF::CrfUtils::WebService;

#
# Package to access CRF model runner via web service
#

use strict;
use warnings;

use MediaWords::Util::Config;
use MediaWords::Util::CrfExtractor;
use CRF::CrfUtils;

use LWP::UserAgent;
use HTTP::Request;
use HTTP::Status qw(:constants);
use Encode;

use Data::Dumper;

use constant DEFAULT_CRF_PORT => 8441;
use constant HTTP_TIMEOUT     => 10;
use constant HTTP_USER_AGENT  => 'MediaCloudExtractor/1.0';

#
# Helpers
#

sub _fatal_error($)
{
    my $error_message = shift;
    CRF::CrfUtils::_fatal_error( $error_message );
}

sub _crf_server_host()
{
    my $config     = MediaWords::Util::Config->get_config();
    my $crf_server = $config->{ crf_web_service }->{ server };

    unless ( $crf_server )
    {
        _fatal_error( "Unable to determine CRF model runner web service server to connect to." );
    }

    unless ( $crf_server =~ /:/ )
    {

        $crf_server .= ':' . DEFAULT_CRF_PORT;
    }

    return $crf_server;
}

my $_crf_server = _crf_server_host();

#
# CRF::CrfUtils "implementation"
#

sub create_model($$$)
{
    my ( $class, $training_data_file, $iterations ) = @_;

    # Clients should use CRF::CrfUtils::InlineJava directly
    _fatal_error( "Not implemented in " . __PACKAGE__ );
}

sub run_model($$$$)
{
    my ( $class, $model_file_name, $test_data_file, $output_fhs ) = @_;

    # Clients should use CRF::CrfUtils::InlineJava directly
    _fatal_error( "Not implemented in " . __PACKAGE__ );
}

sub run_model_with_tmp_file($$$)
{
    my ( $class, $model_file_name, $test_data_array ) = @_;

    _validate_model_file_name( $model_file_name );

    warn "Implementation of this subroutine in " . __PACKAGE__ . " will not create temporary files.\n";

    return run_model_inline_java_data_array( $class, $model_file_name, $test_data_array );
}

sub run_model_with_separate_exec($$$)
{
    my ( $class, $model_file_name, $test_data_array ) = @_;

    _validate_model_file_name( $model_file_name );

    warn "Implementation of this subroutine in " . __PACKAGE__ . " will not execute a separate process.\n";

    return run_model_inline_java_data_array( $class, $model_file_name, $test_data_array );
}

sub run_model_inline_java_data_array($$$)
{
    my ( $class, $model_file_name, $test_data_array ) = @_;

    _validate_model_file_name( $model_file_name );

    my $test_data = join "\n", @{ $test_data_array };

    # If test data is empty
    unless ( $test_data )
    {
        return [];
    }

    my $test_data_encoded;
    eval {
        # Have to encode because HTTP::Request only accepts bytes as POST data
        $test_data_encoded = Encode::encode_utf8( $test_data );
    };
    if ( $@ )
    {
        _fatal_error( "Unable to encode_utf8() data: $test_data" );
    }

    # Make a request
    my $ua = LWP::UserAgent->new();
    $ua->timeout( HTTP_TIMEOUT );
    $ua->agent( HTTP_USER_AGENT );

    unless ( $_crf_server )
    {
        _fatal_error( "Unable to determine CRF model runner web service server to connect to." );
    }

    my $request = HTTP::Request->new( POST => 'http://' . $_crf_server . '/crf' );
    $request->content_type( 'text/plain; charset=utf8' );
    $request->content( $test_data_encoded );

    my $response = $ua->request( $request );

    my $results_string;
    if ( $response->is_success )
    {
        # OK
        $results_string = $response->decoded_content;
    }
    else
    {
        # Error; determine whether we should be blamed for making a malformed
        # request, or is it an extraction error

        if ( $response->header( "Client-Warning" ) =~ /Internal response/ )
        {
            # Error was generated by LWP::UserAgent; likely didn't reach server
            # at all (timeout, unresponsive host, etc.)
            _fatal_error( 'LWP error: ' . $response->status_line . ': ' . $response->decoded_content );

        }
        else
        {
            # Error was generated by server

            my $http_status_code = $response->code;

            if ( $http_status_code == HTTP_METHOD_NOT_ALLOWED or $http_status_code == HTTP_BAD_REQUEST )
            {
                # Not POST, empty POST
                _fatal_error( $response->status_line . ': ' . $response->decoded_content );

            }
            elsif ( $http_status_code == HTTP_INTERNAL_SERVER_ERROR )
            {
                # CRF processing error -- die() so that the error gets caught and logged into a database
                die( 'CRF web service was unable to process the download: ' . $response->decoded_content );

            }
            else
            {
                # Shutdown the extractor on unconfigured responses
                _fatal_error( 'Unknown HTTP response: ' . $response->status_line . ': ' . $response->decoded_content );
            }
        }
    }

    unless ( $results_string )
    {
        _fatal_error( "Server returned nothing for POST data: " . $test_data );
    }

    my $results = [ split( "\n", $results_string ) ];

    return $results;
}

sub train_and_test($$$$)
{
    my ( $class, $files, $output_fhs, $iterations ) = @_;

    # Clients should use CRF::CrfUtils::InlineJava directly
    _fatal_error( "Not implemented in " . __PACKAGE__ );
}

sub _validate_model_file_name($)
{
    my $model_file_name = shift;

    my $expected_model_file_name = MediaWords::Util::CrfExtractor::get_path_to_extractor_model();

    unless ( $model_file_name eq $expected_model_file_name )
    {
        my $error_message = <<"EOF";
FIXME: web service has its very own hardcoded model file name, so
$model_file_name parameter in the subroutines of this package are useless
and misleading.

Expected model path (the one that is hardcoded into a Java class): $expected_model_file_name

Actual model path (the one provided to one of the CRF processing subroutines): $model_file_name
EOF

        _fatal_error( $error_message );
    }
}

1;
